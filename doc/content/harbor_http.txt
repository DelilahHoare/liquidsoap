title: Interactions with the Harbor

h3. Harbor as HTTP server

The harbor server can be used as a HTTP server. You 
can use the function @harbor.http.register@ to register
HTTP handlers for GET and POST requests. Its parameters
are are follow:

@harbor.http.register(port=8080,uri,handler)@ where:
* @port@ is the port where to receive incoming connections
* @uri@ is used to match requested uri. Perl regular expressions are accepted.
* @handler@ is the function used to process requests.

@handler@ function has type:
%%
(~method:string, ~protocol:string, ~data:string, 
 ~headers:[(string*string)], string)->string))->unit
%%
where:
* @method@ is the HTTP method used by the client. Currently, one of @"POST"@ or @"GET"@
* @protocol@ is the HTTP protocol used by the client. Currently, one of @"HTTP/1.0"@ or @"HTTP/1.1"@
* @data@ is the data passed during a POST request
* @headers@ is the list of HTTP headers sent by the client
* @string@ is the (unparsed) uri requested by the client, e.g.: @"/foo?var=bar"@
The @handler@ function returns HTTP and HTML data to be sent to the client,
for instance:
%%
HTTP/1.1 200 OK\r\n
Content-type: text/html\r\n
\r\n
<html><body>It works!</body></html>\r\n
\r\n
%%
(@\r\n@ should always be used for line return
in HTTP content.

This function can be used to create your own HTTP interface. Some examples
are:

h4. Redirect Icecast's pages

Some source clients using the harbor may also request pages that
are served by an icecast server, for instance listeners statistiques.
In this case, you can register the following handler:

%%(icecast_redirect.liq)
# Redirect all files other
# than /admin.* to icecast,
# located at localhost:8000
def redirect_icecast(~method,~protocol,~data,~headers,uri) =
  "HTTP/1.1 301 Moved Permanently\r\n\
   Location: http://localhost:8000#{s}\r\n\r\n"
end

# Register this handler at port 8005
# (provided harbor sources are also served
#  from this port).
harbor.http.register(port=8005,"^/(?!admin)",
                     redirect_icecast)
%%

Another alternative, less recommanded, is to
directly fetch the page's content from the Icecast server:
%%(icecast_proxy.liq)
# Serve all files other
# than /admin.* by fetching data
# from Icecast, located at localhost:8000
def proxy_icecast(~method,~protocol,~data,~headers,uri) =
  def f(x) =
    # Replace Host
    if string.capitalize(fst(x)) == "HOST" then
      "Host: localhost:8000"
    else
      "#{fst(x)}: #{snd(x)}"
    end
  end
  headers = list.map(f,headers)
  headers = string.concat(separator="\r\n",headers)
  request = 
    "#{method} #{uri} #{protocol}\r\n\
     #{headers}\r\n\r\n"
  get_process_output("echo #{quote(request)} | \
                      nc localhost 8000")
end

# Register this handler at port 8005
# (provided harbor sources are also served
#  from this port).
harbor.http.register(port=8005,"^/(?!admin)",
                     proxy_icecast)
%%

This method is not recommenced because some servers may not
close the socket after serving a request, causing @nc@ and
liquidsoap to hang.


h4. Get metadata

You can use harbor to register HTTP services to 
fecth/set the metadata of a source. For instance, 
using the "JSON export function":json.html @json_of@:

%%(get_json_metadata.liq)
meta = ref []

s = (..some source..)

# Update current metadata
# converted in UTF8
def update_meta(m) =
  m = metadata.export(m)
  recode = string.recode(out_enc="UTF-8")
  def f(x) =
    (recode(fst(x)),recode(snd(x)))
  end
  meta := list.map(f,m)
end

# Apply update_metadata
# every time we see a new
# metadata
s = on_metadata(add_meta,s)

# Return the json content
# of meta
def get_meta(~method,~protocol,~data,~headers,uri) =
  m = !meta
  "#{protocol} 200 OK\r\n\
   Content-Type: application/json; charset=utf-8\r\n\r\n\
   #{json_of(m)}\r\n\r\n"
end

# Register get_meta at port 700
harbor.http.register(port=7000,"/getmeta",get_meta)
%%

Once the script is running, 
a GET/POST request for @/getmeta@ at port @7000@
returns the following:
%%
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8

{
  "genre": "Soul",
  "album": "The Complete Stax-Volt Singles: 1959-1968 (Disc 8)",
  "artist": "Astors",
  "title": "Daddy Didn't Tell Me"
}
%%
Which can be used with AJAX-based backends to fetch the current 
metadata of source @s@


h4. Set metadata

TODO

h3. Limitations

When using harbor's HTTP server, please be warned that the server is 
**not** meant to be used under heavy load. Therefore, it should **not**
be exposed to your users/listeners if you expect many of them. In this
case, you should use it as a backend/middle-end and have some kind of 
caching between harbor and the final user. In particular, the harbor server
is not meant to server big files because it loads their entire content in 
memory before sending them.

However, the harbor HTTP server is fully equiped to serve any kind of CGI
script. As a proof of concept, the following code was used to create 
a PHP backend and was successfuly used to run wordpress and SPIP web-applications.

The code is **not** commented, because it is meant as a proof-of-concept and should
**not** be used in production!

%%
def php_handler(path,~method,~protocol,~data,~headers,uri) = 
  log = log(label="php.handler",level=4)
  def sanitize(x) = 
    string.replace(pattern="-",
                   fun (_) -> "_", 
                   string.capitalize(x))
  end
  def f(x) = 
    (sanitize(fst(x)),snd(x))
  end
  l = list.map(f,headers)
  ret = string.extract(pattern="([^\?]*)\?(.*)",uri)
  script = ret["1"]
  script  = 
   if script != "" then
     "#{path}/#{script}"
   else 
     "#{path}/#{uri}"
    end
  script = "#{dirname(script)}/#{basename(script)}"
  script =  
    if test_process("test -d #{quote(script)}") then
     "#{script}/index.php"
    else
     script
   end
  env = "export SERVER_SOFTWARE=Liquidsoap/#{liquidsoap.version}; \
         export SERVER_NAME=localhost; \
         export GATEWAY_INTERFACE=CGI/1.1; \
         export SERVER_PROTOCOL=#{protocol}; \
         export SERVER_PORT=8080; \
         export REQUEST_METHOD=#{method}; \
         export REQUEST_URI=#{quote(uri)}; \
         export REDIRECT_STATUS=200; \
         export SCRIPT_FILENAME=#{quote(script)}"
  def append(env,key,val) = 
    if val != "" then
      "#{env}; export #{key}=#{quote(val)}"
    else
      env
    end
  end
  env = append(env,"CONTENT_TYPE",l["CONTENT_TYPE"])
  env = append(env,"CONTENT_LENGTH",l["CONTENT_LENGTH"]) 
  x =
   if ret["1"] != "" then
     ans = string.extract(pattern="^([^/]*)/([^&=]*)$",ret["2"])
     if ans["1"] != "" then
       script_info = ans["2"]
       (ans["1"],"/#{script_info}")
     else
       (ret["2"],"")
     end
   else
     ("","")
    end
  args = fst(x)
  suffix = snd(x)
  tr_suffix = "#{path}/#{suffix}"
  tr_suffix = "#{dirname(tr_suffix)}/#{basename(tr_suffix)}"
  env = 
    if suffix != "" then
      env = append(env, "PATH_INFO", suffix)
      append(env, "PATH_TRANSLATED", tr_suffix)
    else
      env
    end
  env = append(env,"QUERY_STRING",args)
  env = 
   if l["AUTHORIZATION"] != "" then
     auth = string.extract(pattern="(^[^\s]*\s.*)$",l["AUTHORIZATION"])
     append(env,"AUTH_TYPE",auth["1"])
   else
     env
    end
  env = 
    if suffix != "" then
      append(env,"PATH_TRANSLATED",quote("#{path}/#{suffix}"))
    else
      env
    end
  def f(env,x) = 
    label = sanitize(fst(x))
    val   = snd(x)
    append(env,"HTTP_#{label}",val)
  end
  env = list.fold(f,env,headers)
  data = 
    if method == "POST" then
      "echo #{quote(data)} | "
    else
      ""
    end
  ret = 
    if string.match(pattern="\.php$",script) then
      ret = get_process_output("#{env}; #{data} php-cgi")
      if string.match(pattern="^(?<!\r\n\r\n)Status:",ret) then
        string.replace(pattern="^(?<!\r\n\r\n)Status:",fun (_) -> protocol,ret)
      else
        "#{protocol} 200 OK\r\n#{ret}"
      end
    elsif test_process("test -f #{quote(script)}") then
      last_mod_ts = int_of_string(list.hd(get_process_lines("/usr/bin/stat -c %Y #{quote(script)}")))
      last_mod =  
        list.hd(get_process_lines("LANG=C date -R -d @#{last_mod_ts}"))
      server_headers = "Last-Modified: #{last_mod}\r\n"
      mime = get_mime(script)
      server_headers = 
        if mime != "" then
          "#{server_headers}Content-Type: #{mime}\r\n"
        else
          server_headers
        end
      since_mod = l["IF_MODIFIED_SINCE"]
      def contents () = 
        if string.match(pattern="gzip",l["ACCEPT_ENCODING"]) then
          ("Content-Encoding: gzip\r\n",
           (get_process_output("gzip #{quote(script)} -c")))
        else
          ("",get_process_output("cat #{quote(script)}"))
        end
      end
      x = 
        if since_mod != "" then
          since_mod_ts = int_of_string(list.hd(get_process_lines("date +%s -d #{quote(since_mod)}")))
          if since_mod_ts >= last_mod_ts then
            ("304 (Not Modified)",("",""))
          else
            ("200 OK",contents())
          end
        else
          ("200 OK",contents())
        end
      status = fst(x)
      contents = snd(x)
      server_headers = "#{server_headers}#{fst(contents)}"
      content = snd(contents)
      len = string.length(content)
      server_headers = 
        if len > 0 then
          "#{server_headers}Content-Length: #{len}\r\n"
        else
          server_headers
        end
      log("Returned status #{status}")
      "#{protocol} #{status}\r\n\
       #{server_headers}\r\n\
       #{content}\r\n\r\n"
    else
      log("Returned status 404 File not found!")
      "#{protocol} 404 File not found!\r\n\r\n"
    end
  "#{ret}\r\n\r\n"
end

harbor.http.register(port=8080,".*",php_handler("~/wordpress/"))

harbor.http.register(port=8000,".*",php_handler("~/spip/"))
%%

